import { HMapDataPayload } from './hmap-data';

// declared in host page
declare var haxe: any;
declare var StringTools: any;
declare var ExploCommon: any;

/**
 * JSON map paramaters; feel free to complete
 */
export interface HMapRuinDataJSON {
    _d: boolean;                    // ???
    _h: number;                     // ???
    _k: number;                     // ???
    _r: HMapPatchRuinDataJSON;
    _w: number;                     // ???
    _mid: number;                   // map id
    _zid: number;                   // zone id
}

export interface HMapPatchRuinDataJSON {
    _dirs: Array<boolean>;      // 4 available directions
    _move: boolean;             // ?? can move ?
    _d: {
        _exit: boolean;         // exit place
        _room: any;             // ???
        _seed: number;          // random seed but I dont know what for
        _k: number;             // ?? kills ?
        _w: boolean;            // ???
        _z: number;             // ?? number of zombies
    };
    _o: number;                 // ?? Oxygen ?
    _r: number;                 // ???
    _x: number;                 // x coordinate
    _y: number;                 // y coordinate
}


/**
 * This class is the store of the map. It handles the data originally
 * passed to flash, and expose it in a JSON format with lots of accessors
 */
export class HMapRuinData {

    public static _fakeData: HMapRuinDataJSON;

    public data: HMapRuinDataJSON;

    /**
     * create a fake JSON to debug the map
     */
    static fakeData(force = false): HMapRuinDataJSON {
        if (HMapRuinData._fakeData !== undefined && force === false) {
            return HMapRuinData._fakeData;
        } else {

            // @TODO fake the data

            return HMapRuinData._fakeData;
        }
    }

    /**
     * Decode the url encoded flashvar
     */
    static decode(urlEncoded: string): Object {
        let st: any, hx: any, ec: any;

        try {
            // @ts-ignore
            const page = window.wrappedJSObject;
            if (page !== undefined && page.StringTools && page.MapCommon && page.haxe) { // greasemonkey ...
                st = page.StringTools;
                hx = page.haxe;
                ec = page.MapCommon;
            } else if (StringTools && haxe && ExploCommon) { // tampermonkey
                st = StringTools;
                hx = haxe;
                ec = ExploCommon;
            }

            const tempMapData = st.urlDecode(urlEncoded);
            return hx.Unserializer.run(HMapRuinData.binaryToMessage(ec.genKey(tempMapData.length), ec.permute(tempMapData)));
        } catch (err) {
            console.error('HMapData::decode - caught an exception during decoding', err, urlEncoded);
            throw err;
        }
    }

    /**
     * @param char Type script does not have a type for
     */
    static translate(char: any): any | null {
        if (char >= 65 && char <= 90) {
            return char - 65;
        }
        if (char >= 97 && char <= 122) {
            return char - 71;
        }
        if (char >= 48 && char <= 57) {
            return char + 4;
        }
        return null;
    }

    /**
     * @param key generated by haxe
     * @param message message to decode
     */
    static binaryToMessage(key: any, message: any) {
        const keyArray = new Array();
        for (let i = 0, j = key.length; i < j; i++) {
            const char = HMapRuinData.translate(key.charCodeAt(i));
            if (char != null) {
                keyArray.push(char);
            }
        }
        if (keyArray.length === 0) {
            keyArray.push(0);
        }

        let returnStr = '';
        for (let n = 0, p = message.length; n < p; n++) {
            const k = message.charCodeAt(n) ^ keyArray[(n + message.length) % keyArray.length];
            returnStr += String.fromCharCode((k !== 0) ? k : message.charCodeAt(n));
        }
        return returnStr;
    }

    constructor(mapDataPayload: HMapDataPayload) {
        if (mapDataPayload.raw !== undefined) {
            this.data = HMapRuinData.decode(mapDataPayload.raw) as HMapRuinDataJSON;
        } else if (mapDataPayload.JSON !== undefined) {
            this.data = mapDataPayload.JSON as HMapRuinDataJSON;
        } else {
            throw new Error('Cannot create HMapRuinData from empty parameters');
        }
    }


    patchData(data: HMapDataPayload) {
        let decodedData: HMapPatchRuinDataJSON;
        if (data.raw) {
            decodedData = HMapRuinData.decode(data.raw) as HMapPatchRuinDataJSON;
        } else if (data.JSON) {
            decodedData = data.JSON as HMapPatchRuinDataJSON;
        } else {
            throw new Error('HMapData::patchData - Cannot patch empty data');
        }

        this.patchDataJSON(decodedData!);
    }

    /**
     * JSON patching separated to enable dev mode
     */
    private patchDataJSON(data: HMapPatchRuinDataJSON) {
        this.data._r = data;
    }
}
